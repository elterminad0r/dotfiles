#!/usr/bin/env python3

"""
This is a script that does some drawing with truecolor escape codes in the
terminal. It's a nice little exercise in using truecolor escape codes, and in
generating a colour wheel. It's also "useful" for testing the capabilities of
your current terminal. For example, the output breaks hilariously in URxvt, and
if you've got tmux set up to override truecolor, will look blocky in tmux. It
should look like a smooth colour wheel in that fits on the screen.

It tries to make the circle the right aspect ratio by quering the pixel
dimensions of the current window. If this literally breaks, it will fall back to
the assumption that its output is roughly 1x2 (for example if you don't have
xwininfo or you're running in tmux). However, if you've got some other
circumstance that's causing the pixel dimensions to not be the same as the
actual screen real estate available to the terminal, this circle will probably
be squashed a little.

By default, it tries to take up about 90% of the screen in the relatively
shorter dimension.

If you stare into the centre of the pattern closely for a couple of seconds, and
then quickly switch to something with a white background (like a wall or a
browser), you're in for a trip.
"""

# TODO: let's make this really fast.
#       Also add options for explicit ratios, or something else idk
#       Also, add antialiasing

import sys

from colorsys import hsv_to_rgb
from math import pi, sqrt, atan2
from shutil import get_terminal_size, which
from subprocess import run, CalledProcessError
from os import getenv
from re import findall

SCREEN_USAGE = 0.9

def get_window_id():
    """
    Get current window id.
    """
    if getenv("WINDOWID"):
        return getenv("WINDOWID")
    else:
        try:
            result = run(["xdotool", "getactivewindow"],
                    check=True, capture_output=True)
            return result.stdout.decode().strip()
        except (CalledProcessError, FileNotFoundError) as e:
            raise FileNotFoundError("Cannot get window id")

def get_win_dimensions():
    """
    Get the width and height in pixels of the current window.
    It is only really used for aspect ratio purposes, so the fallback is to just
    say the number of lines by twice the number of columns.
    """
    try:
        result = run(["xwininfo", "-id", get_window_id()],
                check=True, capture_output=True)
        wininfo_lines = [l.strip() for l in result.stdout.decode().split("\n")]
    except (CalledProcessError, FileNotFoundError) as e:
        print(f"not using xwininfo: {e}", file=sys.stderr)
        w, h = get_terminal_size()
        return w, h * 2
    try:
        # this is better because xterm gives its geometry in characters
        d_result = run(["xdotool", "getdisplaygeometry"],
                check=True, capture_output=True)
        d_w, d_h = map(int, d_result.stdout.decode().split())
        corner_text, = (line for line in wininfo_lines
                if line.startswith("Corners:"))
        # NOT A LIST, AN ITERABLE THAT IS CONSUMED
        # separate variable just for intermediate computation
        corners = map(int, findall(r"[-+]\d+", corner_text))
        x_l, y_t, x_r, _, _, y_b, *_ = corners
        return (x_r - x_l) % d_w, (y_b - y_t) % d_h
    except (CalledProcessError, FileNotFoundError) as e:
        print(f"not using xdotool: {e}", file=sys.stderr)
        geom, = (line for line in wininfo_lines if line.startswith("-geometry"))
        w, h, *_ = map(int, findall(r"\d+", geom))
        return w, h

def get_dimensions():
    """
    Determine the dimensions in characters of the block of colour to draw
    """
    px_w, px_h = get_win_dimensions()
    w, h = get_terminal_size()
    # determine the aspect ratio of one character, in order to print as much of
    # a square as possible.
    ratio = (px_h * w) / (px_w * h)
    if w < h * ratio:
        return w, int(w / ratio)
    return int(h * ratio), h

def get_rgb(x, y, w, h):
    """
    Get an ANSI code to set the colour.
    Will set to black if outside the circle, or an appropriate RGB colour
    otherwise.
    """
    # upper limit of distance from origin. +1 to be on the safe side
    hu = atan2(y * w, x * h) / (2 * pi) + 1
    s = 2 * sqrt((x * h) ** 2 + (y * w) ** 2) / (h * w)
    if s < 1:
        return "8;2;{};{};{}m".format(
                *(int(i * 255) for i in hsv_to_rgb(hu, s, 1)))
    return "0m"

def p999():
    """
    Draw a colour wheel
    """
    w, h = (int(SCREEN_USAGE * i) for i in get_dimensions())
    for y in range(-h // 2, h - h // 2):
        for x in range(-w // 2, w - w // 2):
            # Print a unicode upper half-block. This means I can set the
            # foreground for one colour and the background for another, doubling
            # my effective vertical resolution.
            print("\x1b[3{}\x1b[4{}â–€".format(
                get_rgb(x, y, w, h),
                get_rgb(x, y + 0.5, w, h)), end="")
        print("\x1b[0m")

if __name__ == "__main__":
    p999()
