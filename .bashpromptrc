# vim: ft=sh

# FIGMENTIZE: prompt
#                                          __
# ______ _______   ____    _____  ______ _/  |_
# \____ \\_  __ \ /  _ \  /     \ \____ \\   __\
# |  |_> >|  | \/(  <_> )|  Y Y  \|  |_> >|  |
# |   __/ |__|    \____/ |__|_|  /|   __/ |__|
# |__|                         \/ |__|

# file that sets up my flashy bashy prompt

# this part configures the git bit of my prompt. I highly recommend finding this
# script somewhere. It should in theory just come standard with git.

# this is where it is on my system. Find a copy at
# https://github.com/git/git/blob/master/contrib/completion/git-prompt.sh.
# I also have a backuip copy in my .bash_scripts, but that's not under any kind
# of version control or package management.
source_if_exists /usr/share/git/git-prompt.sh "$HOME/.bash_scripts/git-prompt.sh"

# show if there are staged/unstaged changes
GIT_PS1_SHOWDIRTYSTATE=true
# pretty colours
GIT_PS1_SHOWCOLORHINTS=true
# show if there are untracked files
GIT_PS1_SHOWUNTRACKEDFILES=true
# show if you have stashed changes
GIT_PS1_SHOWSTASHSTATE=true
# show relationship with upstream repository
GIT_PS1_SHOWUPSTREAM=auto

# here follow a set of functions I have defined to compartmentalise my prompt a
# little. They make heavy use of tput and \[ \], which are used to output ANSI
# terminal codes, and indicate to Bash that they are non-printing, respectively.

# function which returns a code to make text green if exit status was
# successful, and red otherwise. Indicates the value of a non-zero return
# status. TAKES AN ARGUMENT
exitstatus_prompt() {
    if [[ "$1" == 0 ]]; then
        echo -n "\[$(tput setaf 2)\]@"
    else
        echo -n "\[$(tput setaf 1)\]($1)"
    fi
}

# function to format a nice SHLVL indicating prompt component, to warn about
# nested shells.
shlvl_prompt() {
    if [[ "$SHLVL" = 1 ]]; then
        echo -n "\[$(tput setaf 7)\]|"
    else
        echo -n "\[$(tput setaf 7)\][$SHLVL]"
    fi
}

# function which returns red if the user has root privileges, and pink otherwise
user_prompt() {
    if [[ $EUID -ne 0 ]]; then
        echo -n "\[$(tput setaf 5)\]\u"
    else
        echo -n "\[$(tput setaf 1)\]\1"
    fi
}

# function to return the last two components of PWD, stijn style, with some
# extra formatting.
# UNUSED: I personally just whack my full PWD into my prompt, with
# full_dir_prompt
dir_prompt() {
    # a little logic to make directory behave correctly in / and /*/, and also
    # handle home directory with a little extra logic
    local iz_dir_base="$(basename "$PWD")"
    local iz_dir_dir="$(basename "$(dirname "$PWD")")"
    if [[ "$PWD" = "$HOME" ]]; then
        local iz_dir="~"
    elif [[ "$(dirname "$PWD")" = "$HOME" ]]; then
        local iz_dir="~/$iz_dir_base"
    elif [[ "$iz_dir_base" = "/" ]]; then
        local iz_dir="/"
    elif [[ "$iz_dir_dir" = "/" ]]; then
        local iz_dir="/$iz_dir_base"
    else
        local iz_dir="$iz_dir_dir/$iz_dir_base"
    fi
    echo -n "\[$(tput setaf 6)\]$iz_dir"
}

# display PWD in full.
# I prefer this version because
# 1) I have space to kill as I use a two-line prompt
# 2) It's much faster - dir_prompt is a performance bottleneck, as profiled
#    later on
full_dir_prompt() {
    # uses dirs +0 to display ~ in place of eg /home/izaak
    echo -n "\[$(tput setaf 6)\]$(dirs +0)"
}

# function to display the host name
host_prompt() {
    echo -n "\[$(tput setaf 3)\]\h"
}

# function to display an apparix bookmark if you're in one.
# This is a little bit of a performance bottleneck, as indicated by
# prompt_profile. As far as I can see there aren't any really trivial
# optimisations left, and as it stands it's about 2-3 times slower than any
# other component (ignoring dir_prompt)
apparix_prompt() {
    # assume that amibm has empty output if it's unsuccessful, to avoid having
    # to re-run it
    local izaak_bm=$(amibm)
    if [[ -n "$izaak_bm" ]]; then
        echo -n " \[$(tput setaf 4)\]($izaak_bm)"
    fi
}

if version_assert 4 3 0; then
    # tell the readline library to show a vi mode indicator.
    # this could go in inputrc, but I have my reasons that make it more
    # straightforward to just do it here, for Bash.
    bind "set show-mode-in-prompt on"
    # TODO: is there way to make this work nicely with search mode?
    # also TODO: can I put colours in here without breaking my prompt? who knows. it
    # doesn't seem to understand \[ and \]. Ideally I would have it act the way my
    # "pzsh" prompt looks, but I don't think it will be feasibly. Therefore, I have
    # it go between a character and no character for maximum visibility
    bind "set vi-ins-mode-string \"< >\""
    bind "set vi-cmd-mode-string \"<N>\""
    # this would colour in the matching part of what you're completing on
    # bind "set colored-completion-prefix"
else
    echo "(your bash is too old for a pretty Vi mode indicator)" >&2
fi

# function to build a pretty looking prompt, inspired by Stijn van Dongen's
# taste in prompts, but with more colours.
izaak_prompt() {
    # it's important that this goes first, in order to get the exit status
    # before it runs out
    local IZAAK_EXIT_STATUS="$?"
    # some prompt-escaped terminal codes for ease of reference
    local iz_bold="\[$(tput bold)\]"
    local iz_reset="\[$(tput sgr0)\]"
    # construct the prompt from all the earlier components
    local iz_prompt="$iz_bold$(user_prompt)$(exitstatus_prompt "$IZAAK_EXIT_STATUS")$(host_prompt)$(shlvl_prompt)$(full_dir_prompt)$(apparix_prompt)$iz_reset"

    # Inside here, I put the prompt to use. I've personally got it on two lines,
    # and padded by a line in front, as that's what I've gotten used to from my
    # zsh P10K prompt, but this is optional.

    # the first branch only works if you sourced git-prompt.sh earlier.
    if silent command -v __git_ps1; then
        # This last part uses __git_ps1 to inject some information about dirty
        # states and branches when in a git repository. This can be made much
        # prettier using just vanilla zsh, with the vcs_info autoload function.

        # The two arguments that __git_ps1 takes are a prefix to the git part of
        # the prompt, and a suffix. I leave the suffic as just a space.
        __git_ps1 $'\n'"$iz_prompt" $'\n'" $iz_bold\[$(tput setaf 7)\]->$iz_reset "
    else
        PS1=$'\n'"$iz_prompt"$'\n'" $iz_bold\[$(tput setaf 7)\]->$iz_reset "
    fi
}

PROMPT_COMMAND='izaak_prompt'

# small function to do a very simple profile of the different prompt components
prompt_profile() {
    LOOPS=200
    echo "Profiling each component with $LOOPS loops"
    for component in izaak_prompt user_prompt exitstatus_prompt host_prompt\
        shlvl_prompt full_dir_prompt dir_prompt apparix_prompt; do
        echo
        echo -n "$component..."
        time for i in $(seq 1 1 $LOOPS); do
            # mock some arguments for the component that want them
            silent "$component" 1 1
        done
    done
}
