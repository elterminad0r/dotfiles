#!/usr/bin/env python3

#   __
# _/  |_ _______ _______ _______
# \   __\\_  __ \\_  __ \\_  __ \
#  |  |   |  | \/ |  | \/ |  | \/
#  |__|   |__|    |__|    |__|
# FIGMENTIZE: trrr

"""
Like tr, but it understands Unicode, by way of being a Python 3 program, and it
has built in a fairly large number of fancy looking unicode things.

The translation specs are passed through str.format, with access to a namespace
providing a number of alphabets, which are currently just latin letters with
font variations. This means you can use format specs like

`trrr '{upper}' '{lower}'` to lowercase some text, or

`trrr '{bold}{thin}' '{thin}{bold}'` to swap bold and thin letters.

If the length of the interpolated `to_spec` is a factor of that of `from_spec`,
`to_spec` will be replicated to restore parity. Otherwise, the specs should
generally have the same length. This little trick makes it easy to write  very
much surjective, non-injective mappings, like making everything smallcaps:

`trrr '{letters}' '{sc}'`, or

`trrr '{upper}' '{nm_u}' | trrr '{lower}' '{nm_l}'` to make everything normal.

I have personally defined several aliases with "common" translations that I find
"useful".
"""

import sys
import smartparse as argparse

# Big start gained by scraping from here:
# https://www.compart.com/en/unicode/decomposition/%3Cfont%3E
# let s = ''; for (let e of document.querySelectorAll("p.text,div.text")) {s += e.innerHTML.trim()}; print(s)

# TODO: use some of these
# ğš¨ğš©ğšªğš«ğš¬ğš­ğš®ğš¯ğš°ğš±ğš²ğš³ğš´ğšµğš¶ğš·ğš¸ğš¹ğšºğš»ğš¼ğš½ğš¾ğš¿ğ›€ğ›
# ğ›‚ğ›ƒğ›„ğ›…ğ›†ğ›‡ğ›ˆğ›‰ğ›Šğ›‹ğ›Œğ›ğ›ğ›ğ›ğ›‘ğ›’ğ›“ğ›”ğ›•ğ›–ğ›—ğ›˜ğ›™ğ›šğ››ğ›œğ›ğ›ğ›Ÿğ› ğ›¡
# ğ›¢ğ›£ğ›¤ğ›¥ğ›¦ğ›§ğ›¨ğ›©ğ›ªğ›«ğ›¬ğ›­ğ›®ğ›¯ğ›°ğ›±ğ›²ğ›³ğ›´ğ›µğ›¶ğ›·ğ›¸ğ›¹ğ›ºğ›»
# ğ›¼ğ›½ğ›¾ğ›¿ğœ€ğœğœ‚ğœƒğœ„ğœ…ğœ†ğœ‡ğœˆğœ‰ğœŠğœ‹ğœŒğœğœğœğœğœ‘ğœ’ğœ“ğœ”ğœ•ğœ–ğœ—ğœ˜ğœ™ğœšğœ›ğœœ
# ğœğœğœŸğœ ğœ¡ğœ¢ğœ£ğœ¤ğœ¥ğœ¦ğœ§ğœ¨ğœ©ğœªğœ«ğœ¬ğœ­ğœ®ğœ¯ğœ°ğœ±ğœ²ğœ³ğœ´ğœµ
# ğœ¶ğœ·ğœ¸ğœ¹ğœºğœ»ğœ¼ğœ½ğœ¾ğœ¿ğ€ğğ‚ğƒğ„ğ…ğ†ğ‡ğˆğ‰ğŠğ‹ğŒğğğğğ‘ğ’ğ“ğ”ğ•
# ğ–ğ—ğ˜ğ™ğšğ›ğœğğğŸğ ğ¡ğ¢ğ£ğ¤ğ¥ğ¦ğ§ğ¨ğ©ğªğ«ğ¬ğ­ğ®ğ¯
# ğ°ğ±ğ²ğ³ğ´ğµğ¶ğ·ğ¸ğ¹ğºğ»ğ¼ğ½ğ¾ğ¿ğ€ğğ‚ğƒğ„ğ…ğ†ğ‡ğˆğ‰ğŠğ‹ğŒğğğ
# ğğ‘ğ’ğ“ğ”ğ•ğ–ğ—ğ˜ğ™ğšğ›ğœğğğŸğ ğ¡ğ¢ğ£ğ¤ğ¥ğ¦ğ§ğ¨ğ©
# ğªğ«ğ¬ğ­ğ®ğ¯ğ°ğ±ğ²ğ³ğ´ğµğ¶ğ·ğ¸ğ¹ğºğ»ğ¼ğ½ğ¾ğ¿ğŸ€ğŸğŸ‚ğŸƒğŸ„ğŸ…ğŸ†ğŸ‡ğŸˆğŸ‰
# â„â„“â„¹â„¼â„½â„¾â„¿â…€â……â…†â…‡â…ˆâ…‰
# ï¬ ï¬¡ï¬¢ï¬£ï¬¤ï¬¥ï¬¦ï¬§ï¬¨ï¬©
# ğš¤ğš¥
# ğŸŠğŸ‹

# Some of these may well look a lot like normal ASCII letters, depending on what
# font you're using. However they are not, these are all Unicode letters, with
# explicit semantics about their typesetting.
alphabets = {
    "nm_u": "ABCDEFGHIJKLMNOPQRSTUVWXYZ",
    "nm_l": "abcdefghijklmnopqrstuvwxyz",
    "nm_n": "0123456789",
    "bf_u": "ğ€ğğ‚ğƒğ„ğ…ğ†ğ‡ğˆğ‰ğŠğ‹ğŒğğğğğ‘ğ’ğ“ğ”ğ•ğ–ğ—ğ˜ğ™",
    "bf_l": "ğšğ›ğœğğğŸğ ğ¡ğ¢ğ£ğ¤ğ¥ğ¦ğ§ğ¨ğ©ğªğ«ğ¬ğ­ğ®ğ¯ğ°ğ±ğ²ğ³",
    "bf_n": "ğŸğŸğŸğŸ‘ğŸ’ğŸ“ğŸ”ğŸ•ğŸ–ğŸ—",
    "it_u": "ğ´ğµğ¶ğ·ğ¸ğ¹ğºğ»ğ¼ğ½ğ¾ğ¿ğ‘€ğ‘ğ‘‚ğ‘ƒğ‘„ğ‘…ğ‘†ğ‘‡ğ‘ˆğ‘‰ğ‘Šğ‘‹ğ‘Œğ‘",
    "it_l": "ğ‘ğ‘ğ‘ğ‘‘ğ‘’ğ‘“ğ‘”â„ğ‘–ğ‘—ğ‘˜ğ‘™ğ‘šğ‘›ğ‘œğ‘ğ‘ğ‘Ÿğ‘ ğ‘¡ğ‘¢ğ‘£ğ‘¤ğ‘¥ğ‘¦ğ‘§",
    "bi_u": "ğ‘¨ğ‘©ğ‘ªğ‘«ğ‘¬ğ‘­ğ‘®ğ‘¯ğ‘°ğ‘±ğ‘²ğ‘³ğ‘´ğ‘µğ‘¶ğ‘·ğ‘¸ğ‘¹ğ‘ºğ‘»ğ‘¼ğ‘½ğ‘¾ğ‘¿ğ’€ğ’",
    "bi_l": "ğ’‚ğ’ƒğ’„ğ’…ğ’†ğ’‡ğ’ˆğ’‰ğ’Šğ’‹ğ’Œğ’ğ’ğ’ğ’ğ’‘ğ’’ğ’“ğ’”ğ’•ğ’–ğ’—ğ’˜ğ’™ğ’šğ’›",
    "scr_u": "ğ’œâ„¬ğ’ğ’Ÿâ„°â„±ğ’¢â„‹â„ğ’¥ğ’¦â„’â„³ğ’©ğ’ªğ’«ğ’¬â„›ğ’®ğ’¯ğ’°ğ’±ğ’²ğ’³ğ’´ğ’µ",
    "scr_l": "ğ’¶ğ’·ğ’¸ğ’¹â„¯ğ’»â„Šğ’½ğ’¾ğ’¿ğ“€ğ“ğ“‚ğ“ƒâ„´ğ“…ğ“†ğ“‡ğ“ˆğ“‰ğ“Šğ“‹ğ“Œğ“ğ“ğ“",
    "scb_u": "ğ“ğ“‘ğ“’ğ““ğ“”ğ“•ğ“–ğ“—ğ“˜ğ“™ğ“šğ“›ğ“œğ“ğ“ğ“Ÿğ“ ğ“¡ğ“¢ğ“£ğ“¤ğ“¥ğ“¦ğ“§ğ“¨ğ“©",
    "scb_l": "ğ“ªğ“«ğ“¬ğ“­ğ“®ğ“¯ğ“°ğ“±ğ“²ğ“³ğ“´ğ“µğ“¶ğ“·ğ“¸ğ“¹ğ“ºğ“»ğ“¼ğ“½ğ“¾ğ“¿ğ”€ğ”ğ”‚ğ”ƒ",
    "frk_u": "ğ”„ğ”…â„­ğ”‡ğ”ˆğ”‰ğ”Šâ„Œâ„‘ğ”ğ”ğ”ğ”ğ”‘ğ”’ğ”“ğ””â„œğ”–ğ”—ğ”˜ğ”™ğ”šğ”›ğ”œâ„¨",
    "frk_l": "ğ”ğ”Ÿğ” ğ”¡ğ”¢ğ”£ğ”¤ğ”¥ğ”¦ğ”§ğ”¨ğ”©ğ”ªğ”«ğ”¬ğ”­ğ”®ğ”¯ğ”°ğ”±ğ”²ğ”³ğ”´ğ”µğ”¶ğ”·",
    "frb_u": "ğ•¬ğ•­ğ•®ğ•¯ğ•°ğ•±ğ•²ğ•³ğ•´ğ•µğ•¶ğ•·ğ•¸ğ•¹ğ•ºğ•»ğ•¼ğ•½ğ•¾ğ•¿ğ–€ğ–ğ–‚ğ–ƒğ–„ğ–…",
    "frb_l": "ğ–†ğ–‡ğ–ˆğ–‰ğ–Šğ–‹ğ–Œğ–ğ–ğ–ğ–ğ–‘ğ–’ğ–“ğ–”ğ–•ğ––ğ–—ğ–˜ğ–™ğ–šğ–›ğ–œğ–ğ–ğ–Ÿ",
    "sns_u": "ğ– ğ–¡ğ–¢ğ–£ğ–¤ğ–¥ğ–¦ğ–§ğ–¨ğ–©ğ–ªğ–«ğ–¬ğ–­ğ–®ğ–¯ğ–°ğ–±ğ–²ğ–³ğ–´ğ–µğ–¶ğ–·ğ–¸ğ–¹",
    "sns_l": "ğ–ºğ–»ğ–¼ğ–½ğ–¾ğ–¿ğ—€ğ—ğ—‚ğ—ƒğ—„ğ—…ğ—†ğ—‡ğ—ˆğ—‰ğ—Šğ—‹ğ—Œğ—ğ—ğ—ğ—ğ—‘ğ—’ğ—“",
    "sns_n": "ğŸ¢ğŸ£ğŸ¤ğŸ¥ğŸ¦ğŸ§ğŸ¨ğŸ©ğŸªğŸ«",
    "snb_u": "ğ—”ğ—•ğ—–ğ——ğ—˜ğ—™ğ—šğ—›ğ—œğ—ğ—ğ—Ÿğ— ğ—¡ğ—¢ğ—£ğ—¤ğ—¥ğ—¦ğ—§ğ—¨ğ—©ğ—ªğ—«ğ—¬ğ—­",
    "snb_l": "ğ—®ğ—¯ğ—°ğ—±ğ—²ğ—³ğ—´ğ—µğ—¶ğ—·ğ—¸ğ—¹ğ—ºğ—»ğ—¼ğ—½ğ—¾ğ—¿ğ˜€ğ˜ğ˜‚ğ˜ƒğ˜„ğ˜…ğ˜†ğ˜‡",
    "snb_n": "ğŸ¬ğŸ­ğŸ®ğŸ¯ğŸ°ğŸ±ğŸ²ğŸ³ğŸ´ğŸµ",
    "sni_u": "ğ˜ˆğ˜‰ğ˜Šğ˜‹ğ˜Œğ˜ğ˜ğ˜ğ˜ğ˜‘ğ˜’ğ˜“ğ˜”ğ˜•ğ˜–ğ˜—ğ˜˜ğ˜™ğ˜šğ˜›ğ˜œğ˜ğ˜ğ˜Ÿğ˜ ğ˜¡",
    "sni_l": "ğ˜¢ğ˜£ğ˜¤ğ˜¥ğ˜¦ğ˜§ğ˜¨ğ˜©ğ˜ªğ˜«ğ˜¬ğ˜­ğ˜®ğ˜¯ğ˜°ğ˜±ğ˜²ğ˜³ğ˜´ğ˜µğ˜¶ğ˜·ğ˜¸ğ˜¹ğ˜ºğ˜»",
    "sbi_u": "ğ˜¼ğ˜½ğ˜¾ğ˜¿ğ™€ğ™ğ™‚ğ™ƒğ™„ğ™…ğ™†ğ™‡ğ™ˆğ™‰ğ™Šğ™‹ğ™Œğ™ğ™ğ™ğ™ğ™‘ğ™’ğ™“ğ™”ğ™•",
    "sbi_l": "ğ™–ğ™—ğ™˜ğ™™ğ™šğ™›ğ™œğ™ğ™ğ™Ÿğ™ ğ™¡ğ™¢ğ™£ğ™¤ğ™¥ğ™¦ğ™§ğ™¨ğ™©ğ™ªğ™«ğ™¬ğ™­ğ™®ğ™¯",
    "tt_u": "ğ™°ğ™±ğ™²ğ™³ğ™´ğ™µğ™¶ğ™·ğ™¸ğ™¹ğ™ºğ™»ğ™¼ğ™½ğ™¾ğ™¿ğš€ğšğš‚ğšƒğš„ğš…ğš†ğš‡ğšˆğš‰",
    "tt_l": "ğšŠğš‹ğšŒğšğšğšğšğš‘ğš’ğš“ğš”ğš•ğš–ğš—ğš˜ğš™ğššğš›ğšœğšğšğšŸğš ğš¡ğš¢ğš£",
    "tt_n": "ğŸ¶ğŸ·ğŸ¸ğŸ¹ğŸºğŸ»ğŸ¼ğŸ½ğŸ¾ğŸ¿",
    # TODO: x is faked here
    "sc": "á´€Ê™á´„á´…á´‡êœ°É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜ê¯Ê€êœ±á´›á´œá´ á´¡xÊá´¢",
    "bb_u": "ğ”¸ğ”¹â„‚ğ”»ğ”¼ğ”½ğ”¾â„ğ•€ğ•ğ•‚ğ•ƒğ•„â„•ğ•†â„™â„šâ„ğ•Šğ•‹ğ•Œğ•ğ•ğ•ğ•â„¤",
    "bb_l": "ğ•’ğ•“ğ•”ğ••ğ•–ğ•—ğ•˜ğ•™ğ•šğ•›ğ•œğ•ğ•ğ•Ÿğ• ğ•¡ğ•¢ğ•£ğ•¤ğ•¥ğ•¦ğ•§ğ•¨ğ•©ğ•ªğ•«",
    "bb_n": "ğŸ˜ğŸ™ğŸšğŸ›ğŸœğŸğŸğŸŸğŸ ğŸ¡"}

all_lower = []
all_upper = []

for alph in alphabets:
    if alph.endswith("_u"):
        all_upper.append(alph)
        all_lower.append("{}_l".format(alph.rstrip("_u")))

all_letters = [alph for alph in alphabets if not alph.endswith("_n")]

alphabets["lower"] = "".join(alphabets[a] for a in all_lower)
alphabets["upper"] = "".join(alphabets[a] for a in all_upper)
alphabets["letters"] = "".join(alphabets[a] for a in all_letters)

all_bold = """bf_u bf_l bf_n bi_u bi_l scb_u scb_l frb_u frb_l snb_u snb_l
              snb_n sbi_u sbi_l""".split()
all_thin = """nm_u nm_l nm_n it_u it_l scr_u scr_l frk_u frk_l sns_u sns_l
              sns_n sni_u sni_l""".split()

alphabets["bold"] = "".join(alphabets[a] for a in all_bold)
alphabets["thin"] = "".join(alphabets[a] for a in all_thin)

all_italic = "it_u it_l bi_u bi_l sni_u sni_l sbi_u sbi_l".split()
all_straight = "nm_u nm_l bf_u bf_l sns_u sns_l snb_u snb_l".split()

alphabets["italic"] = "".join(alphabets[a] for a in all_italic)
alphabets["straight"] = "".join(alphabets[a] for a in all_straight)

def summarise_alphabets(alphabets):
    """
    Produce a summary of alphabets
    """
    # determine longest key
    w = max(map(len, alphabets))
    for k, alph in alphabets.items():
        print("{:{w}}: {}".format(k, alph, w=w))

class ListAction(argparse._HelpAction):
    """
    Action that must override any other parsing to produce a list and exit,
    which is actually very similar functionality to -h, so we reappropriate
    HelpAction.
    """
    def __call__(self, parser, namespace, values, option_string=None):
        summarise_alphabets(alphabets)
        sys.exit()

def get_args():
    """
    Parse argv
    """
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("-l", "--list", action=ListAction,
            help="""Do not translate, instead produce a list of available
                    alphabets.""")
    parser.add_argument("from_spec",
            help="Spec for the set of characters to be translated")
    parser.add_argument("to_spec",
            help="Spec for the set of characters to be translated to")
    args = parser.parse_args()
    if not args.to_spec:
        parser.error("to_spec should be nonempty.")
    return args

def trrr(from_spec, to_spec, alphabets):
    """
    Perform the actual translation, interpreting the specs using the alphabets.
    """
    from_full = from_spec.format(**alphabets)
    to_full = to_spec.format(**alphabets)
    if len(from_full) % len(to_full) == 0:
        to_full = to_full * (len(from_full) // len(to_full))
    else:
        print("from_spec should resolve to a length that is a "
              "multiple of that of to_spec",
                file=sys.stderr)
        sys.exit(1)
    trans = str.maketrans(from_full, to_full)
    for line in sys.stdin:
        sys.stdout.write(line.translate(trans))

if __name__ == "__main__":
    args = get_args()
    trrr(args.from_spec, args.to_spec, alphabets)
