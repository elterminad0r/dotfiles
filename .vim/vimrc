"        .__
" ___  __|__|  _____ _______   ____
" \  \/ /|  | /     \\_  __ \_/ ___\
"  \   / |  ||  Y Y  \|  | \/\  \___
"   \_/  |__||__|_|  /|__|    \___  >
"                  \/             \/
" FIGMENTIZE: vimrc

" note to self ":set rl": this is funny, eg do:
" :autocmd BufWinEnter * set rl
" :autocmd CmdWinEnter * set rl
" similarly,
"   set columns=12: smash everything into 12 columns
"                   doesn't work so well on tiling WMs
"   set revins: you write backwards
"   silent !
" a nice combination is :set rl ri<CR>:sil !
" also, :noremap! a b| noremap! b a
" .. etc
" 10000gs
" ggg?G

" TODO: insert-mode mapping to close the innermost unclosed delimiter.
" TODO: text object for a filename, as in <cfile> maybe
" TODO: add mnemonic comments to mappings where appropriate

set encoding=utf-8

" leave the heathens to their folly
if v:progname =~? "evim"
    finish
endif

" Use space as the leader key. This key is used by plugins, and by you, to make
" custom longer mappings. By default it's set to be \ (backslash) which is
" frankly terrible. Space is much faster to type
map <Space> <Nop>
let mapleader = ' '
" To see what kind of mappings there are with it, issue :map <Leader>

" colour-related options, wrapped in some conditions just to be on the safe side
if &t_Co > 2 || has("gui_running")
    syntax enable
    " do not set hlsearch if it is already set, as this will annoyingly
    " re-highlight searches if you've set :noh
    if !&hlsearch
        set hlsearch
    endif
    " when I open a hacked together light terminal, use a light colorscheme.
    " I have this back here already so that background is expose to plugins
    if $GOEDEL_COLORSCHEME == "light"
        set background=light
    else
        set background=dark
    endif
endif

" Source the sub-rc files for various components
source ~/.vim/plugin.vim
source ~/.vim/options.vim
source ~/.vim/mappings.vim
source ~/.vim/command.vim

" some hacky functionality to toggle search highlighting
if !exists("g:goedel_highlighted")
    let g:goedel_highlighted = 1
endif

" noh doesn't work from inside functions, so I use feedkeys instead. This is
" probably pretty fragile or dangerous or whatever but who cares
" TODO: make this cleverer about buffers & rehighlighting when you search
function! ToggleHighlight()
    if &hlsearch
        if g:goedel_highlighted
            call feedkeys(":nohlsearch\<CR>")
        else
            call feedkeys(":set hlsearch\<CR>")
        endif
        let g:goedel_highlighted = xor(1, g:goedel_highlighted)
    endif
endfunction

" Insert mode version
function! IToggleHighlight()
    call feedkeys("\<C-o>")
    call ToggleHighlight()
endfunction

" colour related options that have to happen after sourcing plugins
if &t_Co > 2 || has("gui_running")
    if &term != "linux"
        " if the solarized colorscheme exists, load it
        try
            " provide default colorscheme with not too objectionable
            " highlighting of cursorcolumn, cursorline, line numbers and bad
            " spellings.
            set termguicolors
            colorscheme gruvbox
            " TODO: is there any way to make the background transparent? this
            " way breaks airline:
            " highlight Normal ctermbg=None
            " make special keycodes like ^S legible
            highlight! link SpecialKey Special
            " makes it so I can see what I'm highlighting TODO this gets broken
            " by termguicolors
            " highlight Visual cterm=reverse ctermbg=None
        catch /^Vim\%((\a\+)\)\=:E185/
            colorscheme default
        endtry
    endif
endif

" make useful directories in ~/.vim where they don't exist

" make directory if it does not exist
function! MkDirP(dirname)
    if !isdirectory(a:dirname)
        echomsg "mkdir" a:dirname
        call mkdir(a:dirname)
    endif
endfunction

call MkDirP($HOME . "/.vim")
for dirname in split("backups bundle sessions swap spell undo view")
    call MkDirP($HOME . "/.vim/" . dirname)
endfor

" Basically, let vim load plugins for filetypes.
" This is pretty essential to any vim user's quality of life
" Technically speaking vim-plug already does this for me. however i don't have
" the presence of mind to remember to reinstate this should I grow tired of
" vim-plug, so it stays.
filetype plugin indent on

" similarly name and shame trailing whitespace
highlight TrailingWhitespace ctermbg=red guibg=red
augroup TrailingWhitespaceMatch
    autocmd! VimEnter,WinEnter * match TrailingWhitespace /\s\+$/
augroup END

" generating and using ctags
if executable("ctags")
    function! MakeTags()
        silent !echo "runnning ctags in $(pwd)"; ctags -R -o newtags; mv -f newtags tags
        redraw!
    endfunction
else
    function! MakeTags()
        echoerr "ctags executable not found"
    endfunction
endif

nnoremap <silent> <Leader>c :call MakeTags()<CR>

function! GoedelCheckSearch()
    if !empty($GOEDEL_VIMACK_SEARCH)
        let @/ = $GOEDEL_VIMACK_SEARCH
        silent! normal! n
        call feedkeys(":set hlsearch\<CR>")
    endif
endfunction

augroup SearchGoedelPattern
    autocmd! BufWinEnter * call GoedelCheckSearch()
augroup END

" workaround because you can't redefine a running function.
" This means that if this function is modified, YOU MUST EXIT VIM
if !exists("*ReloadVimConf")
    function! ReloadVimConf()
        source $MYVIMRC
        if has("gui_running")
            source $MYGVIMRC
        endif
        call plug#load(keys(g:plugs))
        redraw | echo "reloaded " . $MYVIMRC
        doautocmd VimEnter
    endfunction
endif
" reload vimrc when written
augroup ConfigReloadVim
    " the nested makes things not break - see autocmd-nested
    autocmd! BufWritePost ~/.vim/*rc,~/.vim/*vim nested call ReloadVimConf()
augroup END

function! ReloadTmuxConf()
    !tmux source-file %
    redraw | echo "reloaded " . @%
endfunction
augroup ConfigReloadTmux
    autocmd! BufWritePost ~/.tmux.conf call ReloadTmuxConf()
augroup END

function! ReloadXConf()
    !xrdb -merge %
    redraw | echo "reloaded ". @%
endfunction
augroup ConfigReloadX
    " TODO: match ~/.X/* not recursively (see :h autocmd-patterns)
    autocmd! BufWritePost ~/.Xresources,~/.Xdefaults,~/.X/* call ReloadXConf()
augroup END

function! ReloadI3Conf()
    !i3-msg restart
    redraw | echo "reloaded " . @%
endfunction
augroup ConfigReloadI3
    autocmd! BufWritePost ~/.config/i3/config,~/.config/i3status/config,~/.conkyrc,~/.config/i3blocks/config call ReloadI3Conf()
augroup END

" function! ToggleAmbiwidth()
"     if &ambiwidth == "single"
"         set ambiwidth=double
"     else
"         set ambiwidth=single
"     endif
" endfunction

" mnemonic: emoji
" nnoremap yoe :call ToggleAmbiwidth()<CR>
